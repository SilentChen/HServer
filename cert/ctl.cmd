第一步：生成私钥
penssl 工具包提供了一个生成 RSA 私钥和 CSR(Certificate Signing Request) 文件的工具。这使得我们可以将其用于生成自签名的证书，从而用于供给 HTTPS 服务器使用。

首先，就是要生成 RSA 私钥。我们生成一个 1024 位的 RSA 秘钥，并使用三重 DES 加密方式，并按照 PEM 格式存储（在库中我们指定了私钥的格式是boost::asio::ssl::context::pem）：

CMD: openssl genrsa -des3 -out server.key 1024

在产生 server.key 时，我们还被要求设置密码，这个密码保护了当别人尝试访问这个私钥时，需要提供密码（作为演示，不妨设置成 123456）
完成后，可以看到产生了 server.key 这个文件。

第二步：生成 CSR
私钥生成后，就可以据此生成一个 CSR 文件了：

CMD: openssl req -new -key server.key -out server.csr

在生成 CSR 文件的过程中，会被要求输入刚才我们设置的保护密码，同时还需要输入一些相关的信息，例如这个证书会被用在哪个域名下。最后会要求设置一个 challenge passwrod，通常不去设置这个密码

第三步：从秘钥中移除密码

如果证书有密码，那么每次使用证书时都讲需要输入一次密码，这不是很方便，况且，秘钥证书位于我们服务器上，不太容易被泄露，因此我们可以将秘钥中的密码移除，首先我们先保存一份秘钥的备份：

CMD: cp server.key server.key.old
CMD: openssl rsa -in server.key.old -out server.key


第四步：生成自签名证书
CMD: openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt

然后在浏览器中访问现在这个运行在 12345 端口的 https 服务器了，输入：https://localhost:12345

这时，我们会看到浏览器正在告诉我们这个链接不安全。

这是由于我们的证书是自签名的产生的原因。一般情况下，自签名的 SSL 证书可以随意的签发，没有第三方监督的审核，并不能收到浏览器的信任。这就非常容易造成伪造证书的中间人攻击，从而导致劫持 SSL 加密流量。

我们刚才在创建证书的时候，指定了这个证书会被用于 shiyanlou.com 这个域名，而实际上我们在访问时，访问的 URL 是 localhost，这时浏览器识别到这个不同，也就阻止了这次连接。

为了测试，我们可以将本次连接添加新人列表中，增加一个安全例外：
这样我们就能看到使用 HTTPS 访问到的资源内容了：
可惜的是，我们依然不能做到像『正经』厂商一样，让那一把小锁变成绿色：
原因就如同之前我们所提到的那样，SSL 证书受到第三方监管，浏览器信任的证书一般来自国外的几个指明 SSL 证书签发商，而这种证书的签发往往需要向签发商支付一定的费用，虽然也有诸如 StartSSL 这样的提供免费 SSL 证书的签发商，但由于我们没有域名进行测试，这里就不再赘述了。
